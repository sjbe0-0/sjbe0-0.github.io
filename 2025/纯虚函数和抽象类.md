##1.纯虚函数和抽象类
C++中的纯虚函数（或者抽象函数）是我们没有实现的虚函数。我们只做声明，通过声明中赋值0来声明纯虚函数。

```C++
Class A {
    public:
        virtual void func() = 0; //纯虚函数
        //other member
}；
```

- 纯虚函数：没有函数体的虚函数。
- 抽象类：包含纯虚函数的类

抽象类只能作为基类来派生新类使用，不能床架抽象类对象，抽象类的指针和引用->由抽象类派生出来的类的对象。

```C++
//abstract_base.h
/*
 * @file abstreact_base.cpp
 * @brief
 * C++中的纯虚函数(或抽象函数)是我们没有实现的虚函数！我们只需声明它!通过声明中赋值0来声明纯虚函数！
 * 纯虚函数：没有函数体的虚函数
 * @author yuejj
 * @version v1
 * @date 2025-09-02
*/

/**
 * @brief 抽象基类
 * @details 包含纯虚函数的类
 */
 class AbstractBase {
    public：
        virtual void show() = 0;
 };


//pure_virtual.cpp
#include <iostream>

using namespace std;

class A {
    private:
        int a;
    public:
        virtual void show() = 0;
};

int main() {
    /*
    *1.抽象类只能作为基类来派生新类使用
    *2.抽象类的指针和引用->由抽象类派生出来的类的对象
    */

    A a;
    A *a1;
    A *a2 = new A; //error:抽象类不能创建对象
}
```

##2.实现抽象类
抽象类：在成员函数内可以调用纯虚函数，在构造函数/析构函数内部不能使用纯虚函数。

如果一个类从抽象类派生而来，他必须实现了基类中的所有纯虚函数才能成为非抽象类。

```C++
class A {
    public:
        virtual void f() = 0;
        void g() {this->f();}
        A(){} // 构造函数
}；

class B: class A {
    public:
        void f() {cout << "B:f()" << endl;} //实现纯虚函数
};

```

##3.重点
- 纯虚函数使得一个类变成抽象类
  抽象类至少包含一个纯虚函数

- 抽象类类型的指针和引用
```C++
class Base {
    public: 
        virtual void show() = 0;
        int getX() {return x;}

    private:
        int x;
};

class Derived : public Base {
    public:
        void show() { cout << "In Derived \n"; } // 实现抽象类的纯虚函数
        Derived(){} // 构造函数
}；

int main() {    
    Base *bp = new Derived(); //抽象类的指针和引用->由抽象类派生出来的类的对象
    bp->show();
    return 0;
}   
```
- 如果我们不在派生类中覆盖纯虚函数，那么派生类也会变成抽象类
- 抽象类也可以有构造函数
```C++
// 抽象类
class Base { 
    protected: 
        int x; 
    public: 
        virtual void fun() = 0; 
        Base(int i) { x = i; }  // 构造函数
}; 
// 派生类
class Derived: public Base 
{ 
    int y; 
public: 
    Derived(int i, int j) : Base(i) { y = j; } // 构造函数
    void fun() { cout << "x = " << x << ", y = " << y; }
}; 
```

- 构造函数不能是虚函数，而析构函数可以是虚函数
```C++
// 抽象类
class Base  {
public:
    Base(){ cout << "Constructor: Base" << endl; }
    virtual ~Base(){ cout << "Destructor : Base" << endl; }
    
    virtual void func() = 0;
};

class Derived: public Base {
public:
    Derived(){ cout << "Constructor: Derived" << endl; }
    ~Derived(){ cout << "Destructor : Derived" << endl;}
    
    void func(){cout << "In Derived.func()." << endl;}
};
```
    当基类指针指向派生类对象并删除对象时，我们可能希望调用适当的析构函数。如果析构函数不是虚拟的，则只能调用基类析构函数。

## 4.实例
```C++
/**
 * @file derived_full.cpp
 * @brief 完整示例！抽象类由派生类继承实现！
 * @author 光城
 * @version v1
 * @date 2019-07-20
 */

#include <iostream>
using namespace std;

class Base {
  int x;

public:
  virtual void fun() = 0;
  int getX() { return x; }
};

class Derived : public Base {
public:
  void fun() { cout << "fun() called"; } // 实现了fun()函数
};

int main(void) {
  Derived d;
  d.fun();
  return 0;
}
```