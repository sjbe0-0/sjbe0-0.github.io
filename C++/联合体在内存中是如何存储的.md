好的，我们来详细讲解联合体（Union）在内存中的存储方式。这是C语言中一个非常重要且有趣的概念。

### 核心原则：共享内存

联合体的所有成员**共享同一块内存空间**。这块空间的大小**足以容纳最大的那个成员**。

这与结构体（Struct）形成鲜明对比，结构体的每个成员都拥有各自独立的内存空间，其总大小是所有成员大小之和（加上可能的对齐填充）。

---

### 内存布局示意图

假设我们定义一个这样的联合体：

```c
union MyUnion {
    int i;      // 假设占4字节
    char c;     // 占1字节
    float f;    // 占4字节
};              // 该联合体总大小至少为4字节（最大成员的大小）
```

它在内存中的布局可以直观地表示为：

```
      ┌─────────────────────────────────┐ ← 内存起始地址
      │                                 │
      │          共享的内存空间           │
      │        (大小 = max(4,1,4) )     │
      │                                 │
      └─────────────────────────────────┘
              ↑         ↑         ↑
              │         │         │
union MyUnion │         │         │
    成员访问: │         │         │
             i         c         f
    (使用4字节) (使用1字节) (使用4字节)
```

**关键点：**
*   无论联合体中有多少个成员，**整个联合体只占一块内存**。
*   这块内存的**起始地址**对于所有成员都是相同的。
*   你**一次只能使用其中一个成员**。给一个成员赋值会覆盖其他成员的值，因为它们共享同一块内存。

---

### 详细示例分析

我们通过一个具体的例子和代码来理解。

#### 1. 定义与大小

```c
#include <stdio.h>

union Data {
    int i;      // 4字节
    char c;     // 1字节
    float f;    // 4字节
    // 可能还有内存对齐带来的额外填充字节
};

int main() {
    union Data data;
    printf("Size of union: %lu bytes\n", sizeof(data)); // 输出很可能是 4 字节
    printf("Address of data.i: %p\n", &data.i);
    printf("Address of data.c: %p\n", &data.c);
    printf("Address of data.f: %p\n", &data.f);

    return 0;
}
```

运行这段代码，你会发现三个成员的**地址完全相同**。这直接证明了它们共享同一块起始内存。

#### 2. 数据存储与覆盖（核心）

```c
data.i = 0x12345678; // 给 int 成员赋值一个特定的十六进制数，便于观察内存

// 此时，整个4字节的内存块被写入了 0x12345678
// 内存布局（假设小端序）：
// 低地址 ────┬──────┬──────┬──────┬──────┐ 高地址
//        │ 0x78 │ 0x56 │ 0x34 │ 0x12 │
//        └──────┴──────┴──────┴──────┘
//         data.c↑ (只访问第1个字节)

printf("data.i after assignment: 0x%x\n", data.i); // 输出: 0x12345678
printf("data.c after assignment: 0x%x\n", data.c); // 输出: 0x78 (最低地址的1字节)

data.c = 0xAA; // 给 char 成员赋值

// 现在，只修改了最低地址的1个字节：
// 低地址 ────┬──────┬──────┬──────┬──────┐ 高地址
//        │ 0xAA │ 0x56 │ 0x34 │ 0x12 │
//        └──────┴──────┴──────┴──────┘

printf("data.i after modifying data.c: 0x%x\n", data.i); // 输出: 0x123456AA
// 注意！data.i 的值被改变了，因为它的第1个字节被 data.c 覆盖了！
printf("data.c after modification: 0x%x\n", data.c); // 输出: 0xAA
```

这个例子清晰地展示了**联合体成员的互斥性**。修改 `data.c` 直接破坏了 `data.i` 的值。

#### 3. 字节序（Endianness）的影响

联合体是查看系统字节序的完美工具。

*   **小端序 (Little-Endian)**：低位字节存储在低地址处（如x86架构）。
*   **大端序 (Big-Endian)**：高位字节存储在低地址处（如某些网络设备）。

```c
data.i = 1;
// 如果系统是小端序：
// 内存布局： [0x01, 0x00, 0x00, 0x00]
// 因此 data.c (访问第1个字节) 的值是 1。

// 如果系统是大端序：
// 内存布局： [0x00, 0x00, 0x00, 0x01]
// 因此 data.c 的值是 0。

if(data.c == 1) {
    printf("This system is Little-Endian.\n");
} else {
    printf("This system is Big-Endian.\n");
}
```

---

### 总结与要点

1.  **共享内存**：所有成员从同一内存地址开始存储。
2.  **大小决定**：联合体的大小由其最大的成员决定，并考虑内存对齐。
3.  **互斥使用**：任一时刻，只有一个成员是有效的。给一个新成员赋值会覆盖之前成员的数据。
4.  **应用场景**：
    *   **节省内存**：当多个数据不会同时使用时（例如，表示不同数据类型的报文）。
    *   **低级数据操作**：像上面的例子一样，拆分或查看数据的字节（类型双关, Type Punning）。
    *   **实现变体记录**。
5.  **安全性**：使用联合体需要程序员自己负责确保当前访问的成员是最后被赋值的那个，否则会读到无意义的数据。编译器通常不会做检查。

理解联合体的内存模型对于进行底层编程、内存操作以及理解C语言灵活性的本质至关重要。